Trickeyのユニット同士は4本の線で接続されています。  
![](images/connector_5.jpg)

4本の内訳はVCC、Clock、Data、GNDと、センサの接続などに用いられるI<sup>2</sup>C(Inter-Integrated Circuit)と同じ配置になっています。また、プロトコル面でもホストユニットがClockを操作をしたり、プルアップされているDataをGNDに落とすことでユニットが通信を行ったりとI<sup>2</sup>Cとの共通点が多く見られます。

こうして見ると「ここまで似せるなら素直にI<sup>2</sup>Cを採用すれば良かったのでは？」と誰でも思うはず。

確かにI<sup>2</sup>Cは汎用的かつ広く普及していますが、I<sup>2</sup>Cを利用する場合、全てのキーユニットに異なるIDを振る必要があります。どの種類のキーが何個接続されるかわからないTrickeyでは、全てのユニットに異なるIDを振るのは煩雑になりすぎます。  
![](images/many_keys.png)

またI<sup>2</sup>Cを採用した場合、ホストユニットが存在しうる全てのデバイスIDをポーリングしなければならないため、遅延なども心配です。  
![](images/poll.png)

これらの問題点を解決するためにTrickeyではI<sup>2</sup>Cをベースとしつつ独自の変更を加えています。

各キーユニットはデバイスIDではなく「キーの種類」を保持しており、
ホストはキーの種類を指定してキーの状態を取得できるようになっています。
同じキーに対応するキーユニットが複数接続されていても正しく押下を検知することが可能です。  
![](images/conflict.png)

またキーのグループを指定することもでき、
グループ内のキーが一つも押されていない場合は探索をスキップすることが可能です。
この仕組みによってTrickeyは入力の遅延を最小限に抑えています。
